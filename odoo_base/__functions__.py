import base64
import hashlib
import hmac
import logging
import time
from cryptography.fernet import Fernet

from odoo import _, http, api
from odoo.exceptions import AccessDenied

_logger = logging.getLogger('odoo')


def str_to_bool(val):
    """Convert a string representation of truth to True, False, or None if ambiguous."""
    # 1) preserve real booleans
    if isinstance(val, bool):
        return val
    # 2) treat missing/none or non‚Äêstring as ambiguous
    if val is None or not isinstance(val, str):
        return None
    # 3) normalize
    v = val.strip().lower()
    if v in ('y', 'yes', 't', 'true', 'on', '1'):
        return True
    if v in ('n', 'no', 'f', 'false', 'off', '0'):
        return False
    # 4) anything else is ambiguous
    return None

def _derive_fernet_key(secret):
    """
    Derive a Fernet key from the provided secret.

    :param secret: The secret string (e.g. the database secret).
    :returns: A URL-safe base64-encoded 32-byte key usable by Fernet.

    Sources:
        - https://cryptography.io/en/latest/fernet/
        - https://cryptography.io/en/latest/hazmat/primitives/cryptographic-primitive-usage/
    """
    # Use SHA256 to get a 32-byte hash and then base64-url encode it.
    key = hashlib.sha256(secret.encode('utf-8')).digest()
    fernet_key = base64.urlsafe_b64encode(key)
    return fernet_key

def fernet_encrypt(secret, plaintext):
    """
    Encrypt the given plaintext using Fernet symmetric encryption.
    Caller is expected to provide the pre-shared secret string (e.g. the database secret).

    :param secret: The pre-shared secret string used to derive the encryption key.
    :param plaintext: The string to encrypt.
    :returns: A URL-safe base64-encoded encrypted string.
    :raises AccessDenied: If no database secret is found.

    Sources:
        - https://cryptography.io/en/latest/fernet/#usage
    """
    fernet_key = _derive_fernet_key(secret)
    f = Fernet(fernet_key)
    ciphertext = f.encrypt(plaintext.encode('utf-8'))
    return ciphertext.decode('utf-8')

def fernet_decrypt(secret, ciphertext):
    """
    Decrypt the given ciphertext using Fernet symmetric decryption.
    Caller is expected to provide the pre-shared secret string (e.g. the database secret).

    :param secret: The pre-shared secret string used to derive the decryption key.
    :param ciphertext: The URL-safe base64-encoded encrypted string.
    :returns: The decrypted plaintext.
    :raises AccessDenied: If no database secret is found or decryption fails.

    Sources:
        - https://cryptography.io/en/latest/fernet/#usage
    """
    fernet_key = _derive_fernet_key(secret)
    f = Fernet(fernet_key)
    try:
        plaintext = f.decrypt(ciphertext.encode('utf-8'))
    except Exception as e:
        raise AccessDenied("Decryption failed.") from e
    return plaintext.decode('utf-8')

def _get_database_secret(env=None):
    """
    Retrieve the database secret ("database.secret").
    A valid execution context is required for this operation.
    """
    if not env:
        raise AccessDenied(_("No execution context available for fetching database secret."))

    secret = env['ir.config_parameter'].sudo().get_param('database.secret')
    if not secret:
        raise AccessDenied(_("CSRF protection misconfigured: no database secret found."))
    return secret

def sign_redirect(env, msg, psk=None):
    """
    Generate a secure redirect signature.

    The signature is generated by:
        1. Computing an HMAC (SHA256) over the provided msg using the database secret.
        2. Appending the current timestamp.
        3. Encrypting the combined string with Fernet encryption (symmetric) using the
            database secret as the psk.
    """
    if not env and not psk:
        raise AccessDenied(_("No execution context or pre-shared key provided for signing."))

    secret = psk or _get_database_secret(env)

    # Generate an HMAC hash for message authentication (irreversible).
    hmac_hash = hmac.new(secret.encode('utf-8'), msg.encode('utf-8'), hashlib.sha256).hexdigest()

    # Append the current timestamp.
    current_time = int(time.time())

    # Encrypt the concatenated string using AES.
    signature = fernet_encrypt(secret, f"{hmac_hash}:{current_time}")

    return signature

def verify_redirect_signature(env, signature, expected_msg, psk=None, expiry=10):
    """
    Verify that the provided signature is valid.

    The method performs the following:
        1. Decrypts the signature using Fernet decryption with the database secret as the psk.
        2. Splits the decrypted string into the original HMAC hash and the timestamp.
        3. Checks that the timestamp is within the allowed expiry window.
        4. Recomputes the expected HMAC hash from the expected_msg.
        5. Compares the recomputed HMAC hash to the one obtained from decryption.
    """
    try:
        secret = psk or _get_database_secret(env)
        decrypted = fernet_decrypt(secret, signature)

        # Expecting the decrypted string to be in the format "<hmac_hash>:<timestamp>"
        decrypted_hmac, ts_str = decrypted.rsplit(":", 1)

        ts = int(ts_str)

    except Exception as e:
        _logger.error("Redirect signature verification failed: %s", e, exc_info=True)
        return False

    # Verify the timestamp is within expiration window
    current_time = int(time.time())
    if abs(current_time - ts) > expiry:
        return False

    # Recompute the expected HMAC hash.
    expected_hmac = hmac.new(secret.encode('utf-8'), expected_msg.encode('utf-8'), hashlib.sha256).hexdigest()

    # Compare the expected HMAC with the decrypted one.
    return hmac.compare_digest(expected_hmac, decrypted_hmac)

def _resolve_env(source):
    """Return an odoo.Environment from source or http.request, or raise."""
    # If passed an actual Environment
    if isinstance(source, api.Environment):
        return source
    # If passed a recordset (models.Model)
    if hasattr(source, 'env'):
        return source.env
    # Finally, try the HTTP request
    try:
        return http.request.env
    except RuntimeError:
        raise RuntimeError(
            "Cannot determine Odoo env: pass in a recordset or call from within an HTTP request."
        )

def get_encrypted_param(source, param_name, storage_model='ir.config_parameter'):
    """
    Read and decrypt a stored parameter using the database secret.
    """
    env = _resolve_env(source)
    store = env[storage_model].sudo()
    secret = _get_database_secret(env)
    encrypted = store.get_param(param_name, '')
    if not encrypted:
        return ''
    try:
        return fernet_decrypt(secret, encrypted)
    except AccessDenied:
        _logger.warning("Access denied decrypting param %s", param_name)
        return ''

def set_encrypted_param(source, param_name, value, storage_model='ir.config_parameter'):
    """
    Encrypt and store a parameter using the database secret.
    """
    env = _resolve_env(source)
    store = env[storage_model].sudo()
    secret = _get_database_secret(env)
    encrypted = fernet_encrypt(secret, value) if value else ''
    store.set_param(param_name, encrypted)
